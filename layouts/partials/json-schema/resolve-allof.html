{{/*

  Resolves the `allOf` keyword (https://spec.openapis.org/oas/v3.1.0#composition-and-inheritance-polymorphism)
  recursively, given a JSON schema object.

  `allOf` is used to support a kind of inheritance for JSON schema objects.

  An object can reference a "parent" object using `allOf`, and it then inherits
  its parent's properties. If the same property is present in the child, then
  we use the child's version (the child overrides the parent).

  Of course the parent can itself inherit from *its* parent, so we recurse to
  handle that.
*/}}

{{ $ret := . }}
{{ $original := . }}

{{ if reflect.IsSlice $ret }}
    {{/*
      If it's a slice, just recurse.
    */}}
    {{ $result_slice := slice }}

    {{ range $ret }}
        {{ $resolved := partial "json-schema/resolve-allof" . }}
        {{ $result_slice = $result_slice | append $resolved }}
    {{ end }}

    {{ $ret = $result_slice }}
{{ end }}

{{ if reflect.IsMap $ret }}
    {{/*
      First, we recurse into the other keys. Doing it now avoids to recurse
      twice in keys resolved by allOf values.
    */}}
    {{ range $key, $value := $ret }}
        {{ if ne $key "allOf" }}
            {{ $resolved := partial "json-schema/resolve-allof" $value }}
            {{ $ret = merge $ret (dict $key $resolved) }}
        {{ end }}
    {{ end }}

    {{/*
      We special-case 'required', and accumulate the values from all the 'allOf'
      entries (rather than simply overriding them). Start the accumulation here.
    */}}
    {{ $required := slice }}

    {{ with $ret.allOf }}

        {{/*
          construct a new dict, with each of the allOf entries merged into it in
          turn.
        */}}
        {{ $all_of_values := dict }}
        {{ range . }}
            {{/*
              First, resolve allOf in child.  
            */}}
            {{ $resolved := partial "json-schema/resolve-allof" . }}

            {{ with $resolved.required }}
                {{ $required = union $required . }}
            {{ end }}

            {{/*
              With merge, values from the second argument override those from the first argument.
              So this order will accumulate values from allOf items, allowing later ones to override earlier

              Note also that `merge` does a *deep* merge - nested maps are also
              merged. (Slices are replaced though.)
            */}}
            {{ $all_of_values = merge $all_of_values $resolved }}
        {{ end }}

        {{/*
          Finally, merge in the original, allowing the original to override allOf.
        */}}
        {{ $ret = merge $all_of_values $ret }}

        {{/*
          special-case 'required': replace it with the union of all the
          'required' arrays from the original and allOf values.
        */}}
        {{ with $ret.required }}
            {{ $required = union $required $ret.required }}
        {{ end }}

        {{ $ret = merge $ret (dict "required" $required) }}
    {{ end }}
{{ end }}

{{ return $ret }}
